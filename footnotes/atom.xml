<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Footnotes by HH Veldstra</title>
 <link href="http://veldstra.org/footnotes/atom.xml" rel="self"/>
 <link href="http://veldstra.org/"/>
 <updated>2012-11-07T18:51:31+00:00</updated>
 <id>http://veldstra.org/</id>
 <author>
   <name>HH Veldstra</name>
   <email>h@veldstra.org</email>
 </author>

 
 <entry>
   <title>Spotify talk at Techmeetup</title>
   <link href="http://veldstra.org/footnotes//2012/10/17/spotify-talk.html"/>
   <updated>2012-10-17T00:00:00+01:00</updated>
   <id>http://veldstra.org/footnotes//2012/10/17/spotify-talk</id>
   <content type="html">&lt;p&gt;Slides from my talk at Edinburgh Techmeetup.&lt;/p&gt;

&lt;script async class=&quot;speakerdeck-embed&quot; data-id=&quot;5076b1709d1165000202d64b&quot; data-ratio=&quot;1.4143646408839778&quot; src=&quot;//speakerdeck.com/assets/embed.js&quot;&gt;&lt;/script&gt;


&lt;p&gt;and a photo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/spotifytalk.jpg&quot; alt=&quot;Hasan Veldstra at Techmeetup&quot; title=&quot;Hasan Veldstra at Techmeetup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The code is on Github: &lt;a href=&quot;http://github.com/hassy/music_hipster&quot;&gt;Music Hipster&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Hello again</title>
   <link href="http://veldstra.org/footnotes//2012/10/17/hello.html"/>
   <updated>2012-10-17T00:00:00+01:00</updated>
   <id>http://veldstra.org/footnotes//2012/10/17/hello</id>
   <content type="html">&lt;p&gt;Here goes my 4th attempt at keeping a blog. Posts from Posterous to be moved when I can be bothered. I have also salvaged two posts that might be of interest to someone from my previous Jekyll blog.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>the future of Lisp...</title>
   <link href="http://veldstra.org/footnotes//2009/05/19/future-of-lisp.html"/>
   <updated>2009-05-19T00:00:00+01:00</updated>
   <id>http://veldstra.org/footnotes//2009/05/19/future-of-lisp</id>
   <content type="html">&lt;p&gt;&amp;#8230;is &lt;a href=&quot;http://clojure.org/&quot;&gt;Clojure&lt;/a&gt;, &lt;a href=&quot;http://github.com/rvirding/lfe/tree&quot;&gt;&lt;span class=&quot;caps&quot;&gt;LFE&lt;/span&gt;&lt;/a&gt; etc, i.e. implementations of Lisp running on top of popular virtual machines. There are two advantages to this approach:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;You get a lot of libraries for free, as long as the author spent a bit of time thinking about interop.&lt;/li&gt;
	&lt;li&gt;(new) Lisp code can live side-by-side with (older) Java, Erlang &amp;amp;c code. There is no need for a radical rewrite or any interop difficulties &amp;#8212; you simply write parts of your system in Lisp where it makes sense, perhaps gradually replacing older non-Lisp code.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This would also mean that:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Lisp&quot;&gt;Common Lisp&lt;/a&gt; is not going to get mainstream for three reasons:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;It&amp;#8217;s full of what looks like cruft to beginners.&lt;/li&gt;
	&lt;li&gt;It&amp;#8217;s not straightforward to get started with. Advising newbies to learn Emacs &amp;amp; &lt;span class=&quot;caps&quot;&gt;SLIME&lt;/span&gt; is not wise and doesn&amp;#8217;t work. Choosing an implementation to start with can be tricky too.&lt;/li&gt;
	&lt;li&gt;The community is not making an effort to make CL seem cool.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://www.plt-scheme.org/&quot;&gt;&lt;span class=&quot;caps&quot;&gt;PLT&lt;/span&gt; Scheme&lt;/a&gt; is not a contender either, because it&amp;#8217;s perceived as little more than a Lisp for teaching, which isn&amp;#8217;t true, but the community isn&amp;#8217;t doing much to shatter this perception.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; discussion over at &lt;a href=&quot;http://news.ycombinator.com/item?id=443948&quot;&gt;Hacker News&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Erlang is pragmatic</title>
   <link href="http://veldstra.org/footnotes//2009/05/16/erlang-is-pragmatic.html"/>
   <updated>2009-05-16T00:00:00+01:00</updated>
   <id>http://veldstra.org/footnotes//2009/05/16/erlang-is-pragmatic</id>
   <content type="html">&lt;p&gt;Yeah, Erlang &lt;a href=&quot;http://james-iry.blogspot.com/2009/05/erlang-is-not-functional.html&quot;&gt;is not&lt;/a&gt; a functional programming language.&lt;/p&gt;
&lt;p&gt;Erlang is a language that makes it easier to write fault-tolerant applications. (And &lt;span class=&quot;caps&quot;&gt;OTP&lt;/span&gt; is the platform that makes it even easier, but not &amp;#8220;easy&amp;#8221; of course.)&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s all about the context.  From day one, the goal of the project that resulted in Erlang as we know it today was to come up with something that made it cheaper and faster to develop telephony systems &amp;#8212; &lt;span class=&quot;caps&quot;&gt;ATM&lt;/span&gt; switches and the like.  There was a lot of tinkering, rewriting, and questioning everything &amp;#8212; even the most basic of assumptions.  There was a solid business requirement, which the Erlang team at Ericsson&amp;#8217;s CS Lab understood well.  They were experienced hackers, with expertise in Prolog, C, Lisp and other programming languages.  They were also experienced in building fault-tolerant systems, and ruthlessly pragmatic.  It was simple: if something helped them get closer to their objective, it went into the language.  If it didn&amp;#8217;t, it got thrown out.&lt;/p&gt;
&lt;p&gt;It turned out that discouraging mutable state brought the language closer to the goal.  Cheap lightweight isolated processes at the core of the language did too.  Currying, algebraic data types and many other features didn&amp;#8217;t.&lt;/p&gt;
&lt;p&gt;Erlang is highly pragmatic, and this seems to get overlooked by many newcomers to the language.  It may be considered functional, and it may also be considered object-oriented, but that does not really matter.  (Some people also call it concurrency-oriented, which is my favorite classification of Erlang.)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cs.chalmers.se/Cs/Grundutb/Kurser/ppxt/HT2007/general/languages/armstrong-erlang_history.pdf&quot;&gt;This paper&lt;/a&gt; helps understand Erlang better.  It sheds light on why Erlang is the way it is, and explains why it&amp;#8217;s by far the best choice for solving certain problems.&lt;/p&gt;</content>
 </entry>
 
 
</feed>