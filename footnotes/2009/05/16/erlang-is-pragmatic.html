<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>Erlang is pragmatic</title>


   <link rel="stylesheet" href="css/syntax.css" type="text/css" />
   <link rel="stylesheet" href="css/screen.css" type="text/css" media="screen, projection" />
   <link href="http://fonts.googleapis.com/css?family=Duru+Sans" rel="stylesheet" type="text/css" />
</head>
<body>

<div class="site">
  <div class="title">
    <h1>Footnotes</h1> by HH Veldstra<br/>
  </div>
  
  <div id="post">
<p>Yeah, Erlang <a href="http://james-iry.blogspot.com/2009/05/erlang-is-not-functional.html">is not</a> a functional programming language.</p>
<p>Erlang is a language that makes it easier to write fault-tolerant applications. (And <span class="caps">OTP</span> is the platform that makes it even easier, but not &#8220;easy&#8221; of course.)</p>
<p>It&#8217;s all about the context.  From day one, the goal of the project that resulted in Erlang as we know it today was to come up with something that made it cheaper and faster to develop telephony systems &#8212; <span class="caps">ATM</span> switches and the like.  There was a lot of tinkering, rewriting, and questioning everything &#8212; even the most basic of assumptions.  There was a solid business requirement, which the Erlang team at Ericsson&#8217;s CS Lab understood well.  They were experienced hackers, with expertise in Prolog, C, Lisp and other programming languages.  They were also experienced in building fault-tolerant systems, and ruthlessly pragmatic.  It was simple: if something helped them get closer to their objective, it went into the language.  If it didn&#8217;t, it got thrown out.</p>
<p>It turned out that discouraging mutable state brought the language closer to the goal.  Cheap lightweight isolated processes at the core of the language did too.  Currying, algebraic data types and many other features didn&#8217;t.</p>
<p>Erlang is highly pragmatic, and this seems to get overlooked by many newcomers to the language.  It may be considered functional, and it may also be considered object-oriented, but that does not really matter.  (Some people also call it concurrency-oriented, which is my favorite classification of Erlang.)</p>
<p><a href="http://www.cs.chalmers.se/Cs/Grundutb/Kurser/ppxt/HT2007/general/languages/armstrong-erlang_history.pdf">This paper</a> helps understand Erlang better.  It sheds light on why Erlang is the way it is, and explains why it&#8217;s by far the best choice for solving certain problems.</p>
</div>

<div id="related">
  <h2>Related Posts</h2>
  <ul class="posts">
    
      <li><span>13 May 2013</span> &raquo; <a href="/2013/05/13/scotlandjs-talk-million-user-realtime-nodejs.html">how I built a Node.js chat app that scales to a million concurrent users</a></li>
    
      <li><span>22 Apr 2013</span> &raquo; <a href="/2013/04/22/ghetto-erlang-deployment.html">ghetto Erlang deployment</a></li>
    
      <li><span>17 Oct 2012</span> &raquo; <a href="/2012/10/17/spotify-talk.html">Spotify talk at Techmeetup</a></li>
    
  </ul>
</div>
  
  <div class="footer">
  </div>
</div>
</body>
</html>
